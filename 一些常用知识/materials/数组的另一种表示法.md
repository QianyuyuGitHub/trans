作者：烈日烤鱼
链接：https://www.zhihu.com/question/66360542/answer/366497654
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

那我说一个C++的非常简单的但可能很多人都不知道的冷知识：你想取数组的第5个元素，你可以怎么写？当然是int b = a[4];这个是地球上码农都知道的对吧。当然了解C或者C++基本常识的也知道还可以这样int b = *(a+4);但可能很多人不知道的是，其实也可以这么写：。。。。。。。。。。。。int b = 4[a];第一次见到这东西的时候，你有没有WTF？这是什么鬼？你确定不是笔误？？但是这确实是正宗的C++。你随便找个编译器试一试，一点毛病没有。滑不滑稽？惊不惊喜？意不意外？这个冷知识介绍到这儿，够冷么？当年我第一次知道还能这么写的时候的确冷了一家伙。但更冷的是：我一直以为知道这写法根本没卵用。谁会这么写代码？这无非是茴字的第5种写法而已。但后来我发现了一个更冷的知识---- 这东西的实际用途！那就是它可以用来做type trait/constraint，用来判断一个类型到底是一个重载了[ ](取下标)操作符的用户定义的类（比如vector），还是一个原生的数组或指针。比如下面这种做法：template <typename T>
void NoSubscriptOp(T &t)
{
 sizeof(t[0]);
 sizeof(0[t]);
}
void NoSubscriptOp(void const * const)
{}
void NoSubscriptOp(void * )
{}
如果你在你的模板里加入NoSubscriptOp这个constraint，那么当模板参数类型是原生数组的话，文件可以编译，否则无法编译。（同样原理配合SFINAE可以做trait。）举个例子：int a[10];
NoSubscriptOp(a);
结果：程序可以编译。std::vector<int> a;  //vector重载了[]操作符。
NoSubscriptOp(a);
结果：程序不可以编译。当然，如果a二者都不是，那也不能编译：int a;
NoSubscriptOp(a);
结果：程序无法编译。结论就是，当你的模板希望只处理原生数组或指针，而不希望处理实现了取下标操作的类（比如vector)的时候，可以使用这个技巧。简单说一下原理：原理就是 Type b = 4[a]; 这个写法，只有在a是原生数组时有效。如果a不是原生数组，而是一个带有取下标操作的类（比如vector），那就是编译错误。而之所以这个操作只在原生数组有效，则是因为C++在处理数组的取下标[ ]操作符时是按指针（逻辑上）展开的：a[4]<=> *(a+4)那既然上式成立4[a] <=> *(4+a) 当然也成立。于是原生数组就能写成4[a]了，取的值和a[4]一样。而对于自定义的类，你的[ ]如何工作，是你自己定义的，自然未必有a[4]<=>*(a+4)这个关系，那4[a] <=> *(4+a) 自然也不成立了。